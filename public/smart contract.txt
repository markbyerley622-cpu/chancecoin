// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/*
  ChanceCoinGame.sol
  - BEP20/ERC20 token staking (approve & transferFrom)
  - Matchmaking by stake-size and side (HEADS/TAILS)
  - Pseudo-random outcomes for instant results
  - 5% house fee
*/

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract ChanceCoinGame is ReentrancyGuard {
    IERC20 public token; // BEP20 token
    address public owner;
    address public feeWallet; // Wallet to receive 5% fee
    uint256 public feePercentage = 5; // 5% fee

    enum Side { NONE, HEADS, TAILS } // 0 unused

    // stake sizes allowed
    uint256[] public allowedStakes;

    struct Player {
        address addr;
        uint256 stake;
        Side side;
    }

    struct Match {
        uint256 id;
        Player p1;
        Player p2;
        uint256 stake; // per player
        bool settled;
    }

    uint256 public nextMatchId;
    mapping(uint256 => Match) public matches; // matchId => Match

    struct QueuedPlayer {
        address addr;
        uint256 stake;
        Side side;
        uint256 timestamp;
    }

    // mapping stake => side => queued player
    mapping(uint256 => mapping(Side => QueuedPlayer)) public singleSlotQueue;

    // events
    event PlayerQueued(address indexed player, uint256 stake, Side side);
    event MatchCreated(uint256 indexed matchId, address p1, address p2, uint256 stake);
    event MatchSettled(uint256 indexed matchId, address winner, uint256 amount);
    event PlayerCancelled(address indexed player, uint256 stake, Side side);

    modifier onlyOwner() {
        require(msg.sender == owner, "only owner");
        _;
    }

    // SIMPLIFIED CONSTRUCTOR
    constructor(
        address _token,
        uint256[] memory _allowedStakes,
        address _feeWallet
    ) {
        require(_token != address(0), "invalid token address");
        require(_feeWallet != address(0), "invalid fee wallet");
        
        owner = msg.sender;
        token = IERC20(_token);
        allowedStakes = _allowedStakes;
        feeWallet = _feeWallet;
        nextMatchId = 1;
    }

    // helper: check stake allowed
    function isAllowedStake(uint256 s) public view returns(bool) {
        for (uint i=0; i<allowedStakes.length; i++) {
            if (allowedStakes[i] == s) return true;
        }
        return false;
    }

    // user calls approve(tokenContract, amount) before calling joinGame
    function joinGame(uint256 stake, uint8 side_) external nonReentrant {
        require(isAllowedStake(stake), "invalid stake");
        require(side_ == uint8(Side.HEADS) || side_ == uint8(Side.TAILS), "invalid side");
        Side side = Side(side_);

        // check opposite queue FIRST before transferring
        Side opposite = (side == Side.HEADS) ? Side.TAILS : Side.HEADS;
        QueuedPlayer memory queued = singleSlotQueue[stake][opposite];

        if (queued.addr != address(0)) {
            // found opponent
            // Transfer current player's tokens first
            bool ok = token.transferFrom(msg.sender, address(this), stake);
            require(ok, "transferFrom failed");
            
            // Now we have BOTH players' tokens in the contract
            address p1 = queued.addr;
            address p2 = msg.sender;

            // clear queue slot
            delete singleSlotQueue[stake][opposite];

            uint256 matchId = nextMatchId++;
            matches[matchId] = Match({
                id: matchId,
                p1: Player({addr: p1, stake: stake, side: opposite}),
                p2: Player({addr: p2, stake: stake, side: side}),
                stake: stake,
                settled: false
            });

            emit MatchCreated(matchId, p1, p2, stake);

            // INSTANTLY SETTLE with pseudo-randomness
            _settleMatchPseudoRandom(matchId);
        } else {
            // No opponent yet - transfer tokens and queue this player
            bool ok = token.transferFrom(msg.sender, address(this), stake);
            require(ok, "transferFrom failed");
            
            singleSlotQueue[stake][side] = QueuedPlayer({
                addr: msg.sender,
                stake: stake,
                side: side,
                timestamp: block.timestamp
            });
            emit PlayerQueued(msg.sender, stake, side);
        }
    }

    // Internal function to settle match with pseudo-randomness
    function _settleMatchPseudoRandom(uint256 matchId) internal {
        Match storage m = matches[matchId];
        require(!m.settled, "already settled");
        require(m.p1.addr != address(0), "p1 invalid");
        require(m.p2.addr != address(0), "p2 invalid");

        // Mark as settled FIRST to prevent reentrancy
        m.settled = true;

        // Pseudo-random outcome using block data
        uint256 rnd = uint256(keccak256(abi.encodePacked(
            block.timestamp, 
            block.prevrandao, 
            block.number,
            matchId,
            m.p1.addr,
            m.p2.addr
        )));
        
        uint winnerIndex = rnd % 2;
        address winner = (winnerIndex == 0) ? m.p1.addr : m.p2.addr;
        uint256 totalPot = m.stake * 2; // Total pot from both players
        
        // Calculate 5% fee
        uint256 fee = (totalPot * feePercentage) / 100;
        uint256 winnerAmount = totalPot - fee;

        // Verify contract has enough balance
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= totalPot, "insufficient contract balance");
        
        // Transfer winner amount first
        require(winner != address(0), "invalid winner");
        require(token.transfer(winner, winnerAmount), "payout failed");
        
        // Transfer fee to fee wallet
        require(feeWallet != address(0), "invalid fee wallet");
        require(token.transfer(feeWallet, fee), "fee transfer failed");

        emit MatchSettled(matchId, winner, winnerAmount);
    }

    // let queued player cancel and get tokens back
    function cancelQueue(uint256 stake, uint8 side_) external nonReentrant {
        require(side_ == uint8(Side.HEADS) || side_ == uint8(Side.TAILS), "invalid side");
        Side side = Side(side_);
        QueuedPlayer memory q = singleSlotQueue[stake][side];
        require(q.addr == msg.sender, "not queued");

        delete singleSlotQueue[stake][side];
        bool ok = token.transfer(msg.sender, stake);
        require(ok, "refund transfer failed");
        emit PlayerCancelled(msg.sender, stake, side);
    }

    // Manual settle function for testing/admin
    function testSettleMatch(uint256 matchId) external onlyOwner {
        _settleMatchPseudoRandom(matchId);
    }

    // ADMIN: Update fee wallet
    function setFeeWallet(address _feeWallet) external onlyOwner {
        require(_feeWallet != address(0), "invalid address");
        feeWallet = _feeWallet;
    }

    // ADMIN: Update fee percentage (in case you want to change it)
    function setFeePercentage(uint256 _feePercentage) external onlyOwner {
        require(_feePercentage <= 10, "fee too high"); // Max 10%
        feePercentage = _feePercentage;
    }

    // ADMIN: Add a new allowed stake amount
    function addAllowedStake(uint256 stake) external onlyOwner {
        for (uint i = 0; i < allowedStakes.length; i++) {
            require(allowedStakes[i] != stake, "stake already allowed");
        }
        allowedStakes.push(stake);
    }

    // ADMIN: Remove an allowed stake amount
    function removeAllowedStake(uint256 stake) external onlyOwner {
        for (uint i = 0; i < allowedStakes.length; i++) {
            if (allowedStakes[i] == stake) {
                allowedStakes[i] = allowedStakes[allowedStakes.length - 1];
                allowedStakes.pop();
                return;
            }
        }
        revert("stake not found");
    }

    // ADMIN: Replace all allowed stakes
    function setAllowedStakes(uint256[] memory _allowedStakes) external onlyOwner {
        allowedStakes = _allowedStakes;
    }

    // View: Get all allowed stakes
    function getAllowedStakes() external view returns (uint256[] memory) {
        return allowedStakes;
    }

    // withdraw accidentally stuck tokens (owner only)
    function emergencyWithdrawToken(address _token, address to, uint256 amount) external onlyOwner {
        IERC20(_token).transfer(to, amount);
    }

    // Withdraw any native BNB/ETH sent to the contract (owner only)
    function emergencyWithdrawBNB(address payable to, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient balance");
        to.transfer(amount);
    }
}