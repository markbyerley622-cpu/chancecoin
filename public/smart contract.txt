// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/*
  ChanceCoinGame - Native BNB Version
  - Uses native BNB instead of tokens
  - Matchmaking by stake-size and side (HEADS/TAILS)
  - Pseudo-random outcomes for instant results
  - 5% house fee
*/

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract ChanceCoinGame is ReentrancyGuard {
    address public owner;
    address public feeWallet;
    uint256 public feePercentage = 5; // 5% fee

    enum Side { NONE, HEADS, TAILS }

    uint256[] public allowedStakes;

    struct Player {
        address addr;
        uint256 stake;
        Side side;
    }

    struct Match {
        uint256 id;
        Player p1;
        Player p2;
        uint256 stake;
        bool settled;
    }

    uint256 public nextMatchId;
    mapping(uint256 => Match) public matches;

    struct QueuedPlayer {
        address addr;
        uint256 stake;
        Side side;
        uint256 timestamp;
    }

    mapping(uint256 => mapping(Side => QueuedPlayer)) public singleSlotQueue;

    event PlayerQueued(address indexed player, uint256 stake, Side side);
    event MatchCreated(uint256 indexed matchId, address p1, address p2, uint256 stake);
    event MatchSettled(uint256 indexed matchId, address winner, uint256 amount);
    event PlayerCancelled(address indexed player, uint256 stake, Side side);

    modifier onlyOwner() {
        require(msg.sender == owner, "only owner");
        _;
    }

    constructor(
        uint256[] memory _allowedStakes,
        address _feeWallet
    ) {
        require(_feeWallet != address(0), "invalid fee wallet");
        
        owner = msg.sender;
        allowedStakes = _allowedStakes;
        feeWallet = _feeWallet;
        nextMatchId = 1;
    }

    function isAllowedStake(uint256 s) public view returns(bool) {
        for (uint i=0; i<allowedStakes.length; i++) {
            if (allowedStakes[i] == s) return true;
        }
        return false;
    }

    // MODIFIED: Now accepts native BNB
    function joinGame(uint8 side_) external payable nonReentrant {
        uint256 stake = msg.value; // Get BNB amount sent
        require(isAllowedStake(stake), "invalid stake");
        require(side_ == uint8(Side.HEADS) || side_ == uint8(Side.TAILS), "invalid side");
        Side side = Side(side_);

        Side opposite = (side == Side.HEADS) ? Side.TAILS : Side.HEADS;
        QueuedPlayer memory queued = singleSlotQueue[stake][opposite];

        if (queued.addr != address(0)) {
            // Found opponent
            address p1 = queued.addr;
            address p2 = msg.sender;

            delete singleSlotQueue[stake][opposite];

            uint256 matchId = nextMatchId++;
            matches[matchId] = Match({
                id: matchId,
                p1: Player({addr: p1, stake: stake, side: opposite}),
                p2: Player({addr: p2, stake: stake, side: side}),
                stake: stake,
                settled: false
            });

            emit MatchCreated(matchId, p1, p2, stake);

            // Instantly settle
            _settleMatchPseudoRandom(matchId);
        } else {
            // No opponent - queue this player
            singleSlotQueue[stake][side] = QueuedPlayer({
                addr: msg.sender,
                stake: stake,
                side: side,
                timestamp: block.timestamp
            });
            emit PlayerQueued(msg.sender, stake, side);
        }
    }

    function _settleMatchPseudoRandom(uint256 matchId) internal {
        Match storage m = matches[matchId];
        require(!m.settled, "already settled");
        require(m.p1.addr != address(0), "p1 invalid");
        require(m.p2.addr != address(0), "p2 invalid");

        m.settled = true;

        // Pseudo-random
        uint256 rnd = uint256(keccak256(abi.encodePacked(
            block.timestamp, 
            block.prevrandao, 
            block.number,
            matchId,
            m.p1.addr,
            m.p2.addr
        )));
        
        uint winnerIndex = rnd % 2;
        address winner = (winnerIndex == 0) ? m.p1.addr : m.p2.addr;
        uint256 totalPot = m.stake * 2;
        
        uint256 fee = (totalPot * feePercentage) / 100;
        uint256 winnerAmount = totalPot - fee;

        require(address(this).balance >= totalPot, "insufficient balance");
        
        // Transfer BNB to winner
        (bool successWinner, ) = payable(winner).call{value: winnerAmount}("");
        require(successWinner, "payout failed");
        
        // Transfer fee
        (bool successFee, ) = payable(feeWallet).call{value: fee}("");
        require(successFee, "fee transfer failed");

        emit MatchSettled(matchId, winner, winnerAmount);
    }

    function cancelQueue(uint256 stake, uint8 side_) external nonReentrant {
        require(side_ == uint8(Side.HEADS) || side_ == uint8(Side.TAILS), "invalid side");
        Side side = Side(side_);
        QueuedPlayer memory q = singleSlotQueue[stake][side];
        require(q.addr == msg.sender, "not queued");

        delete singleSlotQueue[stake][side];
        
        // Refund BNB
        (bool success, ) = payable(msg.sender).call{value: stake}("");
        require(success, "refund failed");
        
        emit PlayerCancelled(msg.sender, stake, side);
    }

    function testSettleMatch(uint256 matchId) external onlyOwner {
        _settleMatchPseudoRandom(matchId);
    }

    function setFeeWallet(address _feeWallet) external onlyOwner {
        require(_feeWallet != address(0), "invalid address");
        feeWallet = _feeWallet;
    }

    function setFeePercentage(uint256 _feePercentage) external onlyOwner {
        require(_feePercentage <= 10, "fee too high");
        feePercentage = _feePercentage;
    }

    function addAllowedStake(uint256 stake) external onlyOwner {
        for (uint i = 0; i < allowedStakes.length; i++) {
            require(allowedStakes[i] != stake, "stake already allowed");
        }
        allowedStakes.push(stake);
    }

    function removeAllowedStake(uint256 stake) external onlyOwner {
        for (uint i = 0; i < allowedStakes.length; i++) {
            if (allowedStakes[i] == stake) {
                allowedStakes[i] = allowedStakes[allowedStakes.length - 1];
                allowedStakes.pop();
                return;
            }
        }
        revert("stake not found");
    }

    function setAllowedStakes(uint256[] memory _allowedStakes) external onlyOwner {
        allowedStakes = _allowedStakes;
    }

    function getAllowedStakes() external view returns (uint256[] memory) {
        return allowedStakes;
    }

    function emergencyWithdrawBNB(address payable to, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient balance");
        (bool success, ) = to.call{value: amount}("");
        require(success, "withdraw failed");
    }

    receive() external payable {}
}